{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\n\nconst Base_1 = __importDefault(require(\"./Base\"));\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\")); // @credit: https://github.com/wanseob/solidity-mmr\n\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\n\n\nclass MerkleMountainRange extends Base_1.default {\n  constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n    super();\n    this.root = Buffer.alloc(0);\n    this.size = 0;\n    this.width = 0;\n    this.hashes = {};\n    this.data = {};\n    leaves = leaves.map(this.bufferify);\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.hashLeafFn = hashLeafFn;\n    this.peakBaggingFn = peakBaggingFn;\n    this.hashBranchFn = hashBranchFn;\n\n    for (const leaf of leaves) {\n      this.append(leaf);\n    }\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n\n\n  append(data) {\n    data = this.bufferify(data);\n    const dataHash = this.hashFn(data);\n    const dataHashHex = this.bufferToHex(dataHash);\n\n    if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n      this.data[dataHashHex] = data;\n    }\n\n    const leaf = this.hashLeaf(this.size + 1, dataHash);\n    this.hashes[this.size + 1] = leaf;\n    this.width += 1; // find peaks for enlarged tree\n\n    const peakIndexes = this.getPeakIndexes(this.width); // the right most peak's value is the new size of the updated tree\n\n    this.size = this.getSize(this.width); // starting from the left-most peak, get all peak hashes\n\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n    } // update the tree root hash\n\n\n    this.root = this.peakBagging(this.width, peaks);\n  }\n  /**\n   * @desc It returns the hash of a leaf node with hash(M | DATA )\n   *       M is the index of the node.\n   */\n\n\n  hashLeaf(index, dataHash) {\n    dataHash = this.bufferify(dataHash);\n\n    if (this.hashLeafFn) {\n      return this.bufferify(this.hashLeafFn(index, dataHash));\n    }\n\n    return this.hashFn(Buffer.concat([this.bufferify(index), dataHash]));\n  }\n  /**\n   * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n   *       M is the index of the node.\n   */\n\n\n  hashBranch(index, left, right) {\n    if (this.hashBranchFn) {\n      return this.bufferify(this.hashBranchFn(index, left, right));\n    }\n\n    return this.hashFn(Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n  }\n\n  getPeaks() {\n    const peakIndexes = this.getPeakIndexes(this.width);\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this.hashes[peakIndexes[i]];\n    }\n\n    return peaks;\n  }\n\n  getLeafIndex(width) {\n    if (width % 2 === 1) {\n      return this.getSize(width);\n    }\n\n    return this.getSize(width - 1) + 1;\n  }\n  /**\n   * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n   *       the given index(size).\n   */\n\n\n  getPeakIndexes(width) {\n    const numPeaks = this.numOfPeaks(width);\n    const peakIndexes = [];\n    let count = 0;\n    let size = 0;\n\n    for (let i = 255; i > 0; i--) {\n      if ((width & 1 << i - 1) !== 0) {\n        // peak exists\n        size = size + (1 << i) - 1;\n        peakIndexes[count++] = size;\n\n        if (peakIndexes.length >= numPeaks) {\n          break;\n        }\n      }\n    }\n\n    if (count !== peakIndexes.length) {\n      throw new Error('invalid bit calculation');\n    }\n\n    return peakIndexes;\n  }\n\n  numOfPeaks(width) {\n    let bits = width;\n    let num = 0;\n\n    while (bits > 0) {\n      if (bits % 2 === 1) {\n        num++;\n      }\n\n      bits = bits >> 1;\n    }\n\n    return num;\n  }\n\n  peakBagging(width, peaks) {\n    const size = this.getSize(width);\n\n    if (this.numOfPeaks(width) !== peaks.length) {\n      throw new Error('received invalid number of peaks');\n    }\n\n    if (width === 0 && !peaks.length) {\n      return Buffer.alloc(0);\n    }\n\n    if (this.peakBaggingFn) {\n      return this.bufferify(this.peakBaggingFn(size, peaks));\n    }\n\n    return this.hashFn(Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n  }\n  /**\n   * @desc It returns the size of the tree.\n   */\n\n\n  getSize(width) {\n    return (width << 1) - this.numOfPeaks(width);\n  }\n  /**\n   * @desc It returns the root value of the tree.\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n   */\n\n\n  getNode(index) {\n    return this.hashes[index];\n  }\n  /**\n   * @desc It returns the height of the highest peak.\n   */\n\n\n  mountainHeight(size) {\n    let height = 1;\n\n    while (1 << height <= size + height) {\n      height++;\n    }\n\n    return height - 1;\n  }\n  /**\n   * @desc It returns the height of the index.\n   */\n\n\n  heightAt(index) {\n    let reducedIndex = index;\n    let peakIndex = 0;\n    let height = 0; // if an index has a left mountain then subtract the mountain\n\n    while (reducedIndex > peakIndex) {\n      reducedIndex -= (1 << height) - 1;\n      height = this.mountainHeight(reducedIndex);\n      peakIndex = (1 << height) - 1;\n    } // index is on the right slope\n\n\n    return height - (peakIndex - reducedIndex);\n  }\n  /**\n   * @desc It returns whether the index is the leaf node or not\n   */\n\n\n  isLeaf(index) {\n    return this.heightAt(index) === 1;\n  }\n  /**\n   * @desc It returns the children when it is a parent node.\n   */\n\n\n  getChildren(index) {\n    const left = index - (1 << this.heightAt(index) - 1);\n    const right = index - 1;\n\n    if (left === right) {\n      throw new Error('not a parent');\n    }\n\n    return [left, right];\n  }\n  /**\n   * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n   */\n\n\n  getMerkleProof(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.isLeaf(index)) {\n      throw new Error('not a leaf');\n    }\n\n    const root = this.root;\n    const width = this.width; // find all peaks for bagging\n\n    const peaks = this.getPeakIndexes(this.width);\n    const peakBagging = [];\n    let cursor = 0;\n\n    for (let i = 0; i < peaks.length; i++) {\n      // collect the hash of all peaks\n      peakBagging[i] = this.hashes[peaks[i]]; // find the peak which includes the target index\n\n      if (peaks[i] >= index && cursor === 0) {\n        cursor = peaks[i];\n      }\n    }\n\n    let left = 0;\n    let right = 0; // get hashes of the siblings in the mountain which the index belgons to.\n    // it moves the cursor from the summit of the mountain down to the target index\n\n    let height = this.heightAt(cursor);\n    const siblings = [];\n\n    while (cursor !== index) {\n      height--;\n      [left, right] = this.getChildren(cursor); // move the cursor down to the left size or right size\n\n      cursor = index <= left ? left : right; // remaining node is the sibling\n\n      siblings[height - 1] = this.hashes[index <= left ? right : left];\n    }\n\n    return {\n      root,\n      width,\n      peakBagging,\n      siblings\n    };\n  }\n  /**\n   * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n   */\n\n\n  verify(root, width, index, value, peaks, siblings) {\n    value = this.bufferify(value);\n    const size = this.getSize(width);\n\n    if (size < index) {\n      throw new Error('index is out of range');\n    } // check the root equals the peak bagging hash\n\n\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    } // find the mountain where the target index belongs to\n\n\n    let cursor = 0;\n    let targetPeak;\n    const peakIndexes = this.getPeakIndexes(width);\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      if (peakIndexes[i] >= index) {\n        targetPeak = peaks[i];\n        cursor = peakIndexes[i];\n        break;\n      }\n    }\n\n    if (!targetPeak) {\n      throw new Error('target not found');\n    } // find the path climbing down\n\n\n    let height = siblings.length + 1;\n    const path = new Array(height);\n    let left = 0;\n    let right = 0;\n\n    while (height > 0) {\n      // record the current cursor and climb down\n      path[--height] = cursor;\n\n      if (cursor === index) {\n        // on the leaf node. Stop climbing down\n        break;\n      } else {\n        // on the parent node. Go left or right\n        [left, right] = this.getChildren(cursor);\n        cursor = index > left ? right : left;\n        continue;\n      }\n    } // calculate the summit hash climbing up again\n\n\n    let node;\n\n    while (height < path.length) {\n      // move cursor\n      cursor = path[height];\n\n      if (height === 0) {\n        // cusor is on the leaf\n        node = this.hashLeaf(cursor, this.hashFn(value));\n      } else if (cursor - 1 === path[height - 1]) {\n        // cursor is on a parent and a siblings is on the left\n        node = this.hashBranch(cursor, siblings[height - 1], node);\n      } else {\n        // cursor is on a parent and a siblings is on the right\n        node = this.hashBranch(cursor, node, siblings[height - 1]);\n      } // climb up\n\n\n      height++;\n    } // computed hash value of the summit should equal to the target peak hash\n\n\n    if (!node.equals(targetPeak)) {\n      throw new Error('hashed peak is invalid');\n    }\n\n    return true;\n  }\n\n  peaksToPeakMap(width, peaks) {\n    const peakMap = {};\n    let bitIndex = 0;\n    let peakRef = 0;\n    let count = peaks.length;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n      peakRef = 1 << height - 1;\n\n      if ((width & peakRef) !== 0) {\n        peakMap[bitIndex] = peaks[--count];\n      } else {\n        peakMap[bitIndex] = 0;\n      }\n    }\n\n    if (count !== 0) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peakMap;\n  }\n\n  peakMapToPeaks(width, peakMap) {\n    const arrLength = this.numOfPeaks(width);\n    const peaks = new Array(arrLength);\n    let count = 0;\n\n    for (let i = 0; i < 32; i++) {\n      if (peakMap[i] !== 0) {\n        peaks[count++] = peakMap[i];\n      }\n    }\n\n    if (count !== arrLength) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peaks;\n  }\n\n  peakUpdate(width, prevPeakMap, itemHash) {\n    const nextPeakMap = {};\n    const newWidth = width + 1;\n    let cursorIndex = this.getLeafIndex(newWidth);\n    let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n    let bitIndex = 0;\n    let peakRef = 0;\n    let prevPeakExist = false;\n    let nextPeakExist = false;\n    let obtained = false;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n\n      if (obtained) {\n        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n      } else {\n        peakRef = 1 << height - 1;\n        prevPeakExist = (width & peakRef) !== 0;\n        nextPeakExist = (newWidth & peakRef) !== 0; // get new cursor node with hashing the peak and the current cursor\n\n        cursorIndex++;\n\n        if (prevPeakExist) {\n          cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n        } // if new peak exists for the bit index\n\n\n        if (nextPeakExist) {\n          // if prev peak exists for the bit index\n          if (prevPeakExist) {\n            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n          } else {\n            nextPeakMap[bitIndex] = cursorNode;\n          }\n\n          obtained = true;\n        } else {\n          nextPeakMap[bitIndex] = 0;\n        }\n      }\n    }\n\n    return nextPeakMap;\n  }\n\n  rollUp(root, width, peaks, itemHashes) {\n    // check the root equals the peak bagging hash\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    }\n\n    let tmpWidth = width;\n    let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n\n    for (let i = 0; i < itemHashes.length; i++) {\n      tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n      tmpWidth++;\n    }\n\n    return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n  }\n  /**\n   * @desc It returns the hash value of the node for the index.\n   *      If the hash already exists it simply returns the stored value. On the other hand,\n   *      it computes hashes recursively downward.\n   *      Only appending an item calls this function.\n   */\n\n\n  _getOrCreateNode(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.hashes[index]) {\n      const [leftIndex, rightIndex] = this.getChildren(index);\n\n      const leftHash = this._getOrCreateNode(leftIndex);\n\n      const rightHash = this._getOrCreateNode(rightIndex);\n\n      this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n    }\n\n    return this.hashes[index];\n  }\n\n}\n\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"sources":["/home/waleed/Desktop/MintWebsites/metaverse/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","Base_1","require","sha256_1","default","constructor","hashFn","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","length","_getOrCreateNode","peakBagging","index","concat","hashBranch","left","right","getPeaks","getLeafIndex","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","getHexRoot","getNode","mountainHeight","height","heightAt","reducedIndex","peakIndex","isLeaf","getChildren","getMerkleProof","cursor","siblings","verify","equals","targetPeak","path","Array","node","peaksToPeakMap","peakMap","bitIndex","peakRef","peakMapToPeaks","arrLength","peakUpdate","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","rollUp","itemHashes","tmpWidth","tmpPeakMap","leftIndex","rightIndex","leftHash","rightHash"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"]},"metadata":{},"sourceType":"script"}
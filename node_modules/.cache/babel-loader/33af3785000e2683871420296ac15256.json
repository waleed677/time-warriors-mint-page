{"ast":null,"code":"'use strict';\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\n\nvar secp256k1v3 = require('./secp256k1-lib/index');\n\nvar der = require('./secp256k1-lib/der');\n/**\r\n * Verify an ECDSA privateKey\r\n * @method privateKeyVerify\r\n * @param {Buffer} privateKey\r\n * @return {boolean}\r\n */\n\n\nvar privateKeyVerify = function privateKeyVerify(privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\r\n * Export a privateKey in DER format\r\n * @method privateKeyExport\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {boolean}\r\n */\n\n\nvar privateKeyExport = function privateKeyExport(privateKey, compressed) {\n  // privateKeyExport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\r\n * Import a privateKey in DER format\r\n * @method privateKeyImport\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\n\n\nvar privateKeyImport = function privateKeyImport(privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n\n  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\r\n * Negate a privateKey by subtracting it from the order of the curve's base point\r\n * @method privateKeyNegate\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\n\n\nvar privateKeyNegate = function privateKeyNegate(privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\r\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\r\n * @method privateKeyModInverse\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\n\n\nvar privateKeyModInverse = function privateKeyModInverse(privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\r\n * Tweak a privateKey by adding tweak to it.\r\n * @method privateKeyTweakAdd\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\n\n\nvar privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\r\n * Tweak a privateKey by multiplying it by a tweak.\r\n * @method privateKeyTweakMul\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\n\n\nvar privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\r\n * Compute the public key for a privateKey.\r\n * @method publicKeyCreate\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\r\n * Convert a publicKey to compressed or uncompressed form.\r\n * @method publicKeyConvert\r\n * @param {Buffer} publicKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\r\n * Verify an ECDSA publicKey.\r\n * @method publicKeyVerify\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\n\n\nvar publicKeyVerify = function publicKeyVerify(publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\r\n * Tweak a publicKey by adding tweak times the generator to it.\r\n * @method publicKeyTweakAdd\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\r\n * Tweak a publicKey by multiplying it by a tweak value\r\n * @method publicKeyTweakMul\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\r\n * Add a given publicKeys together.\r\n * @method publicKeyCombine\r\n * @param {Array<Buffer>} publicKeys\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\r\n * Convert a signature to a normalized lower-S form.\r\n * @method signatureNormalize\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\n\n\nvar signatureNormalize = function signatureNormalize(signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\r\n * Serialize an ECDSA signature in DER format.\r\n * @method signatureExport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\n\n\nvar signatureExport = function signatureExport(signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\r\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\n\n\nvar signatureImport = function signatureImport(signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\r\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImportLax\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\n\n\nvar signatureImportLax = function signatureImportLax(signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n\n  var sigObj = der.signatureImportLax(signature);\n\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\r\n * Create an ECDSA signature. Always return low-S signature.\r\n * @method sign\r\n * @param {Buffer} message\r\n * @param {Buffer} privateKey\r\n * @param {Object} options\r\n * @return {Buffer}\r\n */\n\n\nvar sign = function sign(message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n\n  var signOptions = void 0;\n\n  if (options) {\n    signOptions = {};\n\n    if (options.data === null) {\n      throw new TypeError('options.data should be a Buffer');\n    }\n\n    if (options.data) {\n      // validate option.data length\n      if (options.data.length !== 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n\n      signOptions.data = new Uint8Array(options.data);\n    }\n\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n\n    if (options.noncefn) {\n      //  convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n\n        return Uint8Array.from(buffer);\n      };\n    }\n  }\n\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\r\n * Verify an ECDSA signature.\r\n * @method verify\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\n\n\nvar verify = function verify(message, signature, publicKey) {\n  // note: secp256k1 v4 verify method has a different argument order\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\r\n * Recover an ECDSA public key from a signature.\r\n * @method recover\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Number} recid\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar recover = function recover(message, signature, recid, compressed) {\n  // note: secp256k1 v4 recover method has a different argument order\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\r\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\r\n * @method ecdh\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\n\n\nvar ecdh = function ecdh(publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n/**\r\n * Compute an EC Diffie-Hellman secret and return public key as result\r\n * @method ecdhUnsafe\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\n\n\nvar ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  } // ensure valid privateKey length\n\n\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\n\nmodule.exports = {\n  privateKeyVerify: privateKeyVerify,\n  privateKeyExport: privateKeyExport,\n  privateKeyImport: privateKeyImport,\n  privateKeyNegate: privateKeyNegate,\n  privateKeyModInverse: privateKeyModInverse,\n  privateKeyTweakAdd: privateKeyTweakAdd,\n  privateKeyTweakMul: privateKeyTweakMul,\n  publicKeyCreate: publicKeyCreate,\n  publicKeyConvert: publicKeyConvert,\n  publicKeyVerify: publicKeyVerify,\n  publicKeyTweakAdd: publicKeyTweakAdd,\n  publicKeyTweakMul: publicKeyTweakMul,\n  publicKeyCombine: publicKeyCombine,\n  signatureNormalize: signatureNormalize,\n  signatureExport: signatureExport,\n  signatureImport: signatureImport,\n  signatureImportLax: signatureImportLax,\n  sign: sign,\n  verify: verify,\n  recover: recover,\n  ecdh: ecdh,\n  ecdhUnsafe: ecdhUnsafe\n};","map":{"version":3,"sources":["E:/Freelancing/blockchain/time-warriors-mint-page/node_modules/ethereumjs-util/dist/secp256k1-adapter.js"],"names":["secp256k1","require","secp256k1v3","der","privateKeyVerify","privateKey","length","Uint8Array","from","privateKeyExport","compressed","RangeError","publicKey","privateKeyImport","Error","privateKeyNegate","Buffer","privateKeyModInverse","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeyCombine","publicKeys","keys","forEach","push","signatureNormalize","signature","signatureExport","signatureImport","signatureImportLax","sigObj","sign","message","options","TypeError","signOptions","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","verify","ecdsaVerify","recover","ecdsaRecover","ecdh","ecdhUnsafe","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\r\n\r\nvar secp256k1v3 = require('./secp256k1-lib/index');\r\nvar der = require('./secp256k1-lib/der');\r\n\r\n/**\r\n * Verify an ECDSA privateKey\r\n * @method privateKeyVerify\r\n * @param {Buffer} privateKey\r\n * @return {boolean}\r\n */\r\nvar privateKeyVerify = function privateKeyVerify(privateKey) {\r\n  // secp256k1 v4 version throws when privateKey length is not 32\r\n  if (privateKey.length !== 32) {\r\n    return false;\r\n  }\r\n\r\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\r\n};\r\n\r\n/**\r\n * Export a privateKey in DER format\r\n * @method privateKeyExport\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {boolean}\r\n */\r\nvar privateKeyExport = function privateKeyExport(privateKey, compressed) {\r\n  // privateKeyExport method is not part of secp256k1 v4 package\r\n  // this implementation is based on v3\r\n  if (privateKey.length !== 32) {\r\n    throw new RangeError('private key length is invalid');\r\n  }\r\n\r\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\r\n\r\n  return der.privateKeyExport(privateKey, publicKey, compressed);\r\n};\r\n\r\n/**\r\n * Import a privateKey in DER format\r\n * @method privateKeyImport\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\n\r\nvar privateKeyImport = function privateKeyImport(privateKey) {\r\n  // privateKeyImport method is not part of secp256k1 v4 package\r\n  // this implementation is based on v3\r\n  privateKey = der.privateKeyImport(privateKey);\r\n  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\r\n    return privateKey;\r\n  }\r\n\r\n  throw new Error(\"couldn't import from DER format\");\r\n};\r\n\r\n/**\r\n * Negate a privateKey by subtracting it from the order of the curve's base point\r\n * @method privateKeyNegate\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nvar privateKeyNegate = function privateKeyNegate(privateKey) {\r\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\r\n};\r\n\r\n/**\r\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\r\n * @method privateKeyModInverse\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nvar privateKeyModInverse = function privateKeyModInverse(privateKey) {\r\n  if (privateKey.length !== 32) {\r\n    throw new Error('private key length is invalid');\r\n  }\r\n\r\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\r\n};\r\n\r\n/**\r\n * Tweak a privateKey by adding tweak to it.\r\n * @method privateKeyTweakAdd\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\r\nvar privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\r\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\r\n};\r\n\r\n/**\r\n * Tweak a privateKey by multiplying it by a tweak.\r\n * @method privateKeyTweakMul\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\r\nvar privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\r\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\r\n};\r\n\r\n/**\r\n * Compute the public key for a privateKey.\r\n * @method publicKeyCreate\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\r\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\r\n};\r\n\r\n/**\r\n * Convert a publicKey to compressed or uncompressed form.\r\n * @method publicKeyConvert\r\n * @param {Buffer} publicKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\r\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\r\n};\r\n\r\n/**\r\n * Verify an ECDSA publicKey.\r\n * @method publicKeyVerify\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\r\nvar publicKeyVerify = function publicKeyVerify(publicKey) {\r\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\r\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\r\n    return false;\r\n  }\r\n\r\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\r\n};\r\n\r\n/**\r\n * Tweak a publicKey by adding tweak times the generator to it.\r\n * @method publicKeyTweakAdd\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\r\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\r\n};\r\n\r\n/**\r\n * Tweak a publicKey by multiplying it by a tweak value\r\n * @method publicKeyTweakMul\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\r\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\r\n};\r\n\r\n/**\r\n * Add a given publicKeys together.\r\n * @method publicKeyCombine\r\n * @param {Array<Buffer>} publicKeys\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\r\n  var keys = [];\r\n  publicKeys.forEach(function (publicKey) {\r\n    keys.push(Uint8Array.from(publicKey));\r\n  });\r\n\r\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\r\n};\r\n\r\n/**\r\n * Convert a signature to a normalized lower-S form.\r\n * @method signatureNormalize\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nvar signatureNormalize = function signatureNormalize(signature) {\r\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\r\n};\r\n\r\n/**\r\n * Serialize an ECDSA signature in DER format.\r\n * @method signatureExport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nvar signatureExport = function signatureExport(signature) {\r\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\r\n};\r\n\r\n/**\r\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nvar signatureImport = function signatureImport(signature) {\r\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\r\n};\r\n\r\n/**\r\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImportLax\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nvar signatureImportLax = function signatureImportLax(signature) {\r\n  // signatureImportLax method is not part of secp256k1 v4 package\r\n  // this implementation is based on v3\r\n  // ensure that signature is greater than 0\r\n  if (signature.length === 0) {\r\n    throw new RangeError('signature length is invalid');\r\n  }\r\n\r\n  var sigObj = der.signatureImportLax(signature);\r\n  if (sigObj === null) {\r\n    throw new Error(\"couldn't parse DER signature\");\r\n  }\r\n\r\n  return secp256k1v3.signatureImport(sigObj);\r\n};\r\n\r\n/**\r\n * Create an ECDSA signature. Always return low-S signature.\r\n * @method sign\r\n * @param {Buffer} message\r\n * @param {Buffer} privateKey\r\n * @param {Object} options\r\n * @return {Buffer}\r\n */\r\nvar sign = function sign(message, privateKey, options) {\r\n  if (options === null) {\r\n    throw new TypeError('options should be an Object');\r\n  }\r\n\r\n  var signOptions = void 0;\r\n\r\n  if (options) {\r\n    signOptions = {};\r\n\r\n    if (options.data === null) {\r\n      throw new TypeError('options.data should be a Buffer');\r\n    }\r\n\r\n    if (options.data) {\r\n      // validate option.data length\r\n      if (options.data.length !== 32) {\r\n        throw new RangeError('options.data length is invalid');\r\n      }\r\n\r\n      signOptions.data = new Uint8Array(options.data);\r\n    }\r\n\r\n    if (options.noncefn === null) {\r\n      throw new TypeError('options.noncefn should be a Function');\r\n    }\r\n\r\n    if (options.noncefn) {\r\n      //  convert option.noncefn function signature\r\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\r\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\r\n        var bufferData = data != null ? Buffer.from(data) : null;\r\n\r\n        var buffer = Buffer.from('');\r\n\r\n        if (options.noncefn) {\r\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\r\n        }\r\n\r\n        return Uint8Array.from(buffer);\r\n      };\r\n    }\r\n  }\r\n\r\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\r\n\r\n  return {\r\n    signature: Buffer.from(sig.signature),\r\n    recovery: sig.recid\r\n  };\r\n};\r\n\r\n/**\r\n * Verify an ECDSA signature.\r\n * @method verify\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\r\nvar verify = function verify(message, signature, publicKey) {\r\n  // note: secp256k1 v4 verify method has a different argument order\r\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\r\n};\r\n\r\n/**\r\n * Recover an ECDSA public key from a signature.\r\n * @method recover\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Number} recid\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar recover = function recover(message, signature, recid, compressed) {\r\n  // note: secp256k1 v4 recover method has a different argument order\r\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\r\n};\r\n\r\n/**\r\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\r\n * @method ecdh\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nvar ecdh = function ecdh(publicKey, privateKey) {\r\n  // note: secp256k1 v3 doesn't allow optional parameter\r\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\r\n};\r\n\r\n/**\r\n * Compute an EC Diffie-Hellman secret and return public key as result\r\n * @method ecdhUnsafe\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nvar ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\r\n  // ecdhUnsafe method is not part of secp256k1 v4 package\r\n  // this implementation is based on v3\r\n  // ensure valid publicKey length\r\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\r\n    throw new RangeError('public key length is invalid');\r\n  }\r\n\r\n  // ensure valid privateKey length\r\n  if (privateKey.length !== 32) {\r\n    throw new RangeError('private key length is invalid');\r\n  }\r\n\r\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\r\n};\r\n\r\nmodule.exports = {\r\n  privateKeyVerify: privateKeyVerify,\r\n  privateKeyExport: privateKeyExport,\r\n  privateKeyImport: privateKeyImport,\r\n  privateKeyNegate: privateKeyNegate,\r\n  privateKeyModInverse: privateKeyModInverse,\r\n  privateKeyTweakAdd: privateKeyTweakAdd,\r\n  privateKeyTweakMul: privateKeyTweakMul,\r\n\r\n  publicKeyCreate: publicKeyCreate,\r\n  publicKeyConvert: publicKeyConvert,\r\n  publicKeyVerify: publicKeyVerify,\r\n  publicKeyTweakAdd: publicKeyTweakAdd,\r\n  publicKeyTweakMul: publicKeyTweakMul,\r\n  publicKeyCombine: publicKeyCombine,\r\n\r\n  signatureNormalize: signatureNormalize,\r\n  signatureExport: signatureExport,\r\n  signatureImport: signatureImport,\r\n  signatureImportLax: signatureImportLax,\r\n\r\n  sign: sign,\r\n  verify: verify,\r\n  recover: recover,\r\n\r\n  ecdh: ecdh,\r\n  ecdhUnsafe: ecdhUnsafe\r\n};"]},"metadata":{},"sourceType":"script"}
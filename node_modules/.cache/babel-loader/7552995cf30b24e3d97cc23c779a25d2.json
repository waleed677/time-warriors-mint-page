{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst init_1 = require(\"../init\");\n\nconst Session_1 = require(\"../relay/Session\");\n\nconst types_1 = require(\"../types\");\n\nconst ClientMessage_1 = require(\"./ClientMessage\");\n\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\n\nconst ServerMessage_1 = require(\"./ServerMessage\");\n\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\r\n * WalletLink Connection\r\n */\n\nclass WalletLinkConnection {\n  /**\r\n   * Constructor\r\n   * @param sessionId Session ID\r\n   * @param sessionKey Session Key\r\n   * @param serverUrl Walletlinkd RPC URL\r\n   * @param [WebSocketClass] Custom WebSocket implementation\r\n   */\n  constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    this.walletLinkAnalytics = walletLinkAnalytics; // attempt to reconnect every 5 seconds when disconnected\n\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(state => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {\n      state,\n      sessionIdHash: Session_1.Session.hash(sessionId)\n    })), // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), // wait 5 seconds\n    (0, operators_1.delay)(5000), // check whether it's destroyed again\n    (0, operators_1.filter)(_ => !this.destroyed), // reconnect\n    (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)()).subscribe()); // perform authentication upon connection\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), // if not CONNECTED, emit false immediately\n    (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false))).subscribe(connected => this.connectedSubject.next(connected))); // send heartbeat every n seconds while connected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, start the heartbeat timer\n    (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe(i => // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat())); // handle server's heartbeat responses\n\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat())); // handle link status updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    })); // handle session config updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\r\n   * Make a connection to the server\r\n   */\n\n\n  connect() {\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n\n    this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.ws.connect().subscribe();\n  }\n  /**\r\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\r\n   * instance of WalletLinkConnection\r\n   */\n\n\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.destroyed = true;\n  }\n\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  /**\r\n   * Emit true if connected and authenticated, else false\r\n   * @returns an Observable\r\n   */\n\n\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\r\n   * Emit once connected\r\n   * @returns an Observable\r\n   */\n\n\n  get onceConnected$() {\n    return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\r\n   * Emit true if linked (a guest has joined before)\r\n   * @returns an Observable\r\n   */\n\n\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\r\n   * Emit once when linked\r\n   * @returns an Observable\r\n   */\n\n\n  get onceLinked$() {\n    return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\r\n   * Emit current session config if available, and subsequent updates\r\n   * @returns an Observable for the session config\r\n   */\n\n\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\r\n   * Emit incoming Event messages\r\n   * @returns an Observable for the messages\r\n   */\n\n\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), (0, operators_1.map)(m => m));\n  }\n  /**\r\n   * Set session metadata in SessionConfig object\r\n   * @param key\r\n   * @param value\r\n   * @returns an Observable that completes when successful\r\n   */\n\n\n  setSessionMetadata(key, value) {\n    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\r\n   * Publish an event and emit event ID when successful\r\n   * @param event event name\r\n   * @param data event data\r\n   * @param callWebhook whether the webhook should be invoked\r\n   * @returns an Observable that emits event ID when successful\r\n   */\n\n\n  publishEvent(event, data, callWebhook = false) {\n    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n\n      return res.eventId;\n    }));\n  }\n\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n\n  makeRequest(message, timeout = REQUEST_TIMEOUT) {\n    const reqId = message.id;\n\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return (0, rxjs_1.throwError)(err);\n    } // await server message with corresponding id\n\n\n    return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n  }\n\n  authenticate() {\n    const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n\n  sendIsLinked() {\n    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n  sendGetSessionConfig() {\n    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n}\n\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"sources":["E:/Freelancing/blockchain/time-warriors-mint-page/node_modules/walletlink/dist/connection/WalletLinkConnection.js"],"names":["Object","defineProperty","exports","value","WalletLinkConnection","rxjs_1","require","operators_1","init_1","Session_1","types_1","ClientMessage_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","sessionId","sessionKey","serverUrl","walletLinkAnalytics","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","sendEvent","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","undefined","webhookId","webhookUrl","Error","STARTED_CONNECTING","destroy","unsubscribe","disconnect","isDestroyed","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","_a","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\r\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\r\n// Licensed under the Apache License, version 2.0\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WalletLinkConnection = void 0;\r\nconst rxjs_1 = require(\"rxjs\");\r\nconst operators_1 = require(\"rxjs/operators\");\r\nconst init_1 = require(\"../init\");\r\nconst Session_1 = require(\"../relay/Session\");\r\nconst types_1 = require(\"../types\");\r\nconst ClientMessage_1 = require(\"./ClientMessage\");\r\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\r\nconst ServerMessage_1 = require(\"./ServerMessage\");\r\nconst HEARTBEAT_INTERVAL = 10000;\r\nconst REQUEST_TIMEOUT = 60000;\r\n/**\r\n * WalletLink Connection\r\n */\r\nclass WalletLinkConnection {\r\n    /**\r\n     * Constructor\r\n     * @param sessionId Session ID\r\n     * @param sessionKey Session Key\r\n     * @param serverUrl Walletlinkd RPC URL\r\n     * @param [WebSocketClass] Custom WebSocket implementation\r\n     */\r\n    constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {\r\n        this.sessionId = sessionId;\r\n        this.sessionKey = sessionKey;\r\n        this.subscriptions = new rxjs_1.Subscription();\r\n        this.destroyed = false;\r\n        this.lastHeartbeatResponse = 0;\r\n        this.nextReqId = (0, types_1.IntNumber)(1);\r\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\r\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\r\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\r\n        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\r\n        this.ws = ws;\r\n        this.walletLinkAnalytics = walletLinkAnalytics;\r\n        // attempt to reconnect every 5 seconds when disconnected\r\n        this.subscriptions.add(ws.connectionState$\r\n            .pipe((0, operators_1.tap)(state => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {\r\n            state,\r\n            sessionIdHash: Session_1.Session.hash(sessionId)\r\n        })), \r\n        // ignore initial DISCONNECTED state\r\n        (0, operators_1.skip)(1), \r\n        // if DISCONNECTED and not destroyed\r\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \r\n        // wait 5 seconds\r\n        (0, operators_1.delay)(5000), \r\n        // check whether it's destroyed again\r\n        (0, operators_1.filter)(_ => !this.destroyed), \r\n        // reconnect\r\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\r\n            .subscribe());\r\n        // perform authentication upon connection\r\n        this.subscriptions.add(ws.connectionState$\r\n            .pipe(\r\n        // ignore initial DISCONNECTED and CONNECTING states\r\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \r\n        // if CONNECTED, authenticate, and then check link status\r\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \r\n        // if not CONNECTED, emit false immediately\r\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\r\n            .subscribe(connected => this.connectedSubject.next(connected)));\r\n        // send heartbeat every n seconds while connected\r\n        this.subscriptions.add(ws.connectionState$\r\n            .pipe(\r\n        // ignore initial DISCONNECTED state\r\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \r\n        // if CONNECTED, start the heartbeat timer\r\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\r\n            .subscribe(i => \r\n        // first timer event updates lastHeartbeat timestamp\r\n        // subsequent calls send heartbeat message\r\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\r\n        // handle server's heartbeat responses\r\n        this.subscriptions.add(ws.incomingData$\r\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\r\n            .subscribe(_ => this.updateLastHeartbeat()));\r\n        // handle link status updates\r\n        this.subscriptions.add(ws.incomingJSONData$\r\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\r\n            .subscribe(m => {\r\n            const msg = m;\r\n            this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {\r\n                sessionIdHash: Session_1.Session.hash(sessionId),\r\n                linked: msg.linked,\r\n                type: m.type,\r\n                onlineGuests: msg.onlineGuests\r\n            });\r\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\r\n        }));\r\n        // handle session config updates\r\n        this.subscriptions.add(ws.incomingJSONData$\r\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\r\n            .subscribe(m => {\r\n            const msg = m;\r\n            this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {\r\n                sessionIdHash: Session_1.Session.hash(sessionId),\r\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\r\n            });\r\n            this.sessionConfigSubject.next({\r\n                webhookId: msg.webhookId,\r\n                webhookUrl: msg.webhookUrl,\r\n                metadata: msg.metadata\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Make a connection to the server\r\n     */\r\n    connect() {\r\n        if (this.destroyed) {\r\n            throw new Error(\"instance is destroyed\");\r\n        }\r\n        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {\r\n            sessionIdHash: Session_1.Session.hash(this.sessionId)\r\n        });\r\n        this.ws.connect().subscribe();\r\n    }\r\n    /**\r\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\r\n     * instance of WalletLinkConnection\r\n     */\r\n    destroy() {\r\n        this.subscriptions.unsubscribe();\r\n        this.ws.disconnect();\r\n        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {\r\n            sessionIdHash: Session_1.Session.hash(this.sessionId)\r\n        });\r\n        this.destroyed = true;\r\n    }\r\n    get isDestroyed() {\r\n        return this.destroyed;\r\n    }\r\n    /**\r\n     * Emit true if connected and authenticated, else false\r\n     * @returns an Observable\r\n     */\r\n    get connected$() {\r\n        return this.connectedSubject.asObservable();\r\n    }\r\n    /**\r\n     * Emit once connected\r\n     * @returns an Observable\r\n     */\r\n    get onceConnected$() {\r\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\r\n    }\r\n    /**\r\n     * Emit true if linked (a guest has joined before)\r\n     * @returns an Observable\r\n     */\r\n    get linked$() {\r\n        return this.linkedSubject.asObservable();\r\n    }\r\n    /**\r\n     * Emit once when linked\r\n     * @returns an Observable\r\n     */\r\n    get onceLinked$() {\r\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\r\n    }\r\n    /**\r\n     * Emit current session config if available, and subsequent updates\r\n     * @returns an Observable for the session config\r\n     */\r\n    get sessionConfig$() {\r\n        return this.sessionConfigSubject.asObservable();\r\n    }\r\n    /**\r\n     * Emit incoming Event messages\r\n     * @returns an Observable for the messages\r\n     */\r\n    get incomingEvent$() {\r\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\r\n            if (m.type !== \"Event\") {\r\n                return false;\r\n            }\r\n            const sme = m;\r\n            return (typeof sme.sessionId === \"string\" &&\r\n                typeof sme.eventId === \"string\" &&\r\n                typeof sme.event === \"string\" &&\r\n                typeof sme.data === \"string\");\r\n        }), (0, operators_1.map)(m => m));\r\n    }\r\n    /**\r\n     * Set session metadata in SessionConfig object\r\n     * @param key\r\n     * @param value\r\n     * @returns an Observable that completes when successful\r\n     */\r\n    setSessionMetadata(key, value) {\r\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\r\n            id: (0, types_1.IntNumber)(this.nextReqId++),\r\n            sessionId: this.sessionId,\r\n            metadata: { [key]: value }\r\n        });\r\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\r\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\r\n                throw new Error(res.error || \"failed to set session metadata\");\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Publish an event and emit event ID when successful\r\n     * @param event event name\r\n     * @param data event data\r\n     * @param callWebhook whether the webhook should be invoked\r\n     * @returns an Observable that emits event ID when successful\r\n     */\r\n    publishEvent(event, data, callWebhook = false) {\r\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\r\n            id: (0, types_1.IntNumber)(this.nextReqId++),\r\n            sessionId: this.sessionId,\r\n            event,\r\n            data,\r\n            callWebhook\r\n        });\r\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\r\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\r\n                throw new Error(res.error || \"failed to publish event\");\r\n            }\r\n            return res.eventId;\r\n        }));\r\n    }\r\n    sendData(message) {\r\n        this.ws.sendData(JSON.stringify(message));\r\n    }\r\n    updateLastHeartbeat() {\r\n        this.lastHeartbeatResponse = Date.now();\r\n    }\r\n    heartbeat() {\r\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\r\n            this.ws.disconnect();\r\n            return;\r\n        }\r\n        try {\r\n            this.ws.sendData(\"h\");\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\r\n        const reqId = message.id;\r\n        try {\r\n            this.sendData(message);\r\n        }\r\n        catch (err) {\r\n            return (0, rxjs_1.throwError)(err);\r\n        }\r\n        // await server message with corresponding id\r\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\r\n    }\r\n    authenticate() {\r\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\r\n            id: (0, types_1.IntNumber)(this.nextReqId++),\r\n            sessionId: this.sessionId,\r\n            sessionKey: this.sessionKey\r\n        });\r\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\r\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\r\n                throw new Error(res.error || \"failed to authentcate\");\r\n            }\r\n        }));\r\n    }\r\n    sendIsLinked() {\r\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\r\n            id: (0, types_1.IntNumber)(this.nextReqId++),\r\n            sessionId: this.sessionId\r\n        });\r\n        this.sendData(msg);\r\n    }\r\n    sendGetSessionConfig() {\r\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\r\n            id: (0, types_1.IntNumber)(this.nextReqId++),\r\n            sessionId: this.sessionId\r\n        });\r\n        this.sendData(msg);\r\n    }\r\n}\r\nexports.WalletLinkConnection = WalletLinkConnection;\r\n"]},"metadata":{},"sourceType":"script"}
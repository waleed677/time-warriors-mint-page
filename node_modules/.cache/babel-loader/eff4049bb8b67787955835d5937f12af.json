{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst buffer_1 = __importDefault(require(\"buffer\"));\n\nconst keccak_1 = __importDefault(require(\"keccak\"));\n\nconst Buffer = buffer_1.default.Buffer;\n\nfunction keccak256(value) {\n  value = toBuffer(value);\n  return (0, keccak_1.default)('keccak256').update(value).digest();\n}\n\nfunction toBuffer(value) {\n  if (!Buffer.isBuffer(value)) {\n    if (Array.isArray(value)) {\n      value = Buffer.from(value);\n    } else if (typeof value === 'string') {\n      if (isHexString(value)) {\n        value = Buffer.from(padToEven(stripHexPrefix(value)), 'hex');\n      } else {\n        value = Buffer.from(value);\n      }\n    } else if (typeof value === 'number') {\n      value = intToBuffer(value);\n    } else if (value === null || value === undefined) {\n      value = Buffer.allocUnsafe(0);\n    } else if (bn_js_1.default.isBN(value)) {\n      value = value.toArrayLike(Buffer);\n    } else if (value.toArray) {\n      // converts a BN to a Buffer\n      value = Buffer.from(value.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n\n  return value;\n}\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction padToEven(value) {\n  if (typeof value !== 'string') {\n    throw new Error(`while padding to even, value must be string, is currently ${typeof value}, while padToEven.`);\n  }\n\n  if (value.length % 2) {\n    value = `0${value}`;\n  }\n\n  return value;\n}\n\nfunction stripHexPrefix(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  return isHexPrefixed(value) ? value.slice(2) : value;\n}\n\nfunction isHexPrefixed(value) {\n  if (typeof value !== 'string') {\n    throw new Error(\"value must be type 'string', is currently type \" + typeof value + ', while checking isHexPrefixed.');\n  }\n\n  return value.slice(0, 2) === '0x';\n}\n\nfunction intToBuffer(i) {\n  const hex = intToHex(i);\n  return Buffer.from(padToEven(hex.slice(2)), 'hex');\n}\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return `0x${hex}`;\n}\n\nif (typeof window !== 'undefined') {\n  window.keccak256 = keccak256;\n}\n\nmodule.exports = keccak256;","map":{"version":3,"sources":["/home/waleed/Desktop/MintWebsites/metaverse/node_modules/keccak256/dist/keccak256.js"],"names":["__importDefault","mod","__esModule","bn_js_1","require","buffer_1","keccak_1","Buffer","default","keccak256","value","toBuffer","update","digest","isBuffer","Array","isArray","from","isHexString","padToEven","stripHexPrefix","intToBuffer","undefined","allocUnsafe","isBN","toArrayLike","toArray","Error","length","match","isHexPrefixed","slice","i","hex","intToHex","toString","window","module","exports"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGA,MAAME,OAAO,GAAGH,eAAe,CAACI,OAAO,CAAC,OAAD,CAAR,CAA/B;;AACA,MAAMC,QAAQ,GAAGL,eAAe,CAACI,OAAO,CAAC,QAAD,CAAR,CAAhC;;AACA,MAAME,QAAQ,GAAGN,eAAe,CAACI,OAAO,CAAC,QAAD,CAAR,CAAhC;;AACA,MAAMG,MAAM,GAAGF,QAAQ,CAACG,OAAT,CAAiBD,MAAhC;;AACA,SAASE,SAAT,CAAmBC,KAAnB,EAA0B;AACtBA,EAAAA,KAAK,GAAGC,QAAQ,CAACD,KAAD,CAAhB;AACA,SAAO,CAAC,GAAGJ,QAAQ,CAACE,OAAb,EAAsB,WAAtB,EAAmCI,MAAnC,CAA0CF,KAA1C,EAAiDG,MAAjD,EAAP;AACH;;AACD,SAASF,QAAT,CAAkBD,KAAlB,EAAyB;AACrB,MAAI,CAACH,MAAM,CAACO,QAAP,CAAgBJ,KAAhB,CAAL,EAA6B;AACzB,QAAIK,KAAK,CAACC,OAAN,CAAcN,KAAd,CAAJ,EAA0B;AACtBA,MAAAA,KAAK,GAAGH,MAAM,CAACU,IAAP,CAAYP,KAAZ,CAAR;AACH,KAFD,MAGK,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAChC,UAAIQ,WAAW,CAACR,KAAD,CAAf,EAAwB;AACpBA,QAAAA,KAAK,GAAGH,MAAM,CAACU,IAAP,CAAYE,SAAS,CAACC,cAAc,CAACV,KAAD,CAAf,CAArB,EAA8C,KAA9C,CAAR;AACH,OAFD,MAGK;AACDA,QAAAA,KAAK,GAAGH,MAAM,CAACU,IAAP,CAAYP,KAAZ,CAAR;AACH;AACJ,KAPI,MAQA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAChCA,MAAAA,KAAK,GAAGW,WAAW,CAACX,KAAD,CAAnB;AACH,KAFI,MAGA,IAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKY,SAAhC,EAA2C;AAC5CZ,MAAAA,KAAK,GAAGH,MAAM,CAACgB,WAAP,CAAmB,CAAnB,CAAR;AACH,KAFI,MAGA,IAAIpB,OAAO,CAACK,OAAR,CAAgBgB,IAAhB,CAAqBd,KAArB,CAAJ,EAAiC;AAClCA,MAAAA,KAAK,GAAGA,KAAK,CAACe,WAAN,CAAkBlB,MAAlB,CAAR;AACH,KAFI,MAGA,IAAIG,KAAK,CAACgB,OAAV,EAAmB;AACpB;AACAhB,MAAAA,KAAK,GAAGH,MAAM,CAACU,IAAP,CAAYP,KAAK,CAACgB,OAAN,EAAZ,CAAR;AACH,KAHI,MAIA;AACD,YAAM,IAAIC,KAAJ,CAAU,cAAV,CAAN;AACH;AACJ;;AACD,SAAOjB,KAAP;AACH;;AACD,SAASQ,WAAT,CAAqBR,KAArB,EAA4BkB,MAA5B,EAAoC;AAChC,MAAI,OAAOlB,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAK,CAACmB,KAAN,CAAY,kBAAZ,CAAlC,EAAmE;AAC/D,WAAO,KAAP;AACH;;AACD,MAAID,MAAM,IAAIlB,KAAK,CAACkB,MAAN,KAAiB,IAAI,IAAIA,MAAvC,EAA+C;AAC3C,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH;;AACD,SAAST,SAAT,CAAmBT,KAAnB,EAA0B;AACtB,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM,IAAIiB,KAAJ,CAAW,6DAA4D,OAAOjB,KAAM,oBAApF,CAAN;AACH;;AACD,MAAIA,KAAK,CAACkB,MAAN,GAAe,CAAnB,EAAsB;AAClBlB,IAAAA,KAAK,GAAI,IAAGA,KAAM,EAAlB;AACH;;AACD,SAAOA,KAAP;AACH;;AACD,SAASU,cAAT,CAAwBV,KAAxB,EAA+B;AAC3B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAOA,KAAP;AACH;;AACD,SAAOoB,aAAa,CAACpB,KAAD,CAAb,GAAuBA,KAAK,CAACqB,KAAN,CAAY,CAAZ,CAAvB,GAAwCrB,KAA/C;AACH;;AACD,SAASoB,aAAT,CAAuBpB,KAAvB,EAA8B;AAC1B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM,IAAIiB,KAAJ,CAAU,oDAAqD,OAAOjB,KAA5D,GAAqE,iCAA/E,CAAN;AACH;;AACD,SAAOA,KAAK,CAACqB,KAAN,CAAY,CAAZ,EAAe,CAAf,MAAsB,IAA7B;AACH;;AACD,SAASV,WAAT,CAAqBW,CAArB,EAAwB;AACpB,QAAMC,GAAG,GAAGC,QAAQ,CAACF,CAAD,CAApB;AACA,SAAOzB,MAAM,CAACU,IAAP,CAAYE,SAAS,CAACc,GAAG,CAACF,KAAJ,CAAU,CAAV,CAAD,CAArB,EAAqC,KAArC,CAAP;AACH;;AACD,SAASG,QAAT,CAAkBF,CAAlB,EAAqB;AACjB,QAAMC,GAAG,GAAGD,CAAC,CAACG,QAAF,CAAW,EAAX,CAAZ;AACA,SAAQ,KAAIF,GAAI,EAAhB;AACH;;AACD,IAAI,OAAOG,MAAP,KAAkB,WAAtB,EAAmC;AAC/BA,EAAAA,MAAM,CAAC3B,SAAP,GAAmBA,SAAnB;AACH;;AACD4B,MAAM,CAACC,OAAP,GAAiB7B,SAAjB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst buffer_1 = __importDefault(require(\"buffer\"));\nconst keccak_1 = __importDefault(require(\"keccak\"));\nconst Buffer = buffer_1.default.Buffer;\nfunction keccak256(value) {\n    value = toBuffer(value);\n    return (0, keccak_1.default)('keccak256').update(value).digest();\n}\nfunction toBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n        if (Array.isArray(value)) {\n            value = Buffer.from(value);\n        }\n        else if (typeof value === 'string') {\n            if (isHexString(value)) {\n                value = Buffer.from(padToEven(stripHexPrefix(value)), 'hex');\n            }\n            else {\n                value = Buffer.from(value);\n            }\n        }\n        else if (typeof value === 'number') {\n            value = intToBuffer(value);\n        }\n        else if (value === null || value === undefined) {\n            value = Buffer.allocUnsafe(0);\n        }\n        else if (bn_js_1.default.isBN(value)) {\n            value = value.toArrayLike(Buffer);\n        }\n        else if (value.toArray) {\n            // converts a BN to a Buffer\n            value = Buffer.from(value.toArray());\n        }\n        else {\n            throw new Error('invalid type');\n        }\n    }\n    return value;\n}\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nfunction padToEven(value) {\n    if (typeof value !== 'string') {\n        throw new Error(`while padding to even, value must be string, is currently ${typeof value}, while padToEven.`);\n    }\n    if (value.length % 2) {\n        value = `0${value}`;\n    }\n    return value;\n}\nfunction stripHexPrefix(value) {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    return isHexPrefixed(value) ? value.slice(2) : value;\n}\nfunction isHexPrefixed(value) {\n    if (typeof value !== 'string') {\n        throw new Error(\"value must be type 'string', is currently type \" + (typeof value) + ', while checking isHexPrefixed.');\n    }\n    return value.slice(0, 2) === '0x';\n}\nfunction intToBuffer(i) {\n    const hex = intToHex(i);\n    return Buffer.from(padToEven(hex.slice(2)), 'hex');\n}\nfunction intToHex(i) {\n    const hex = i.toString(16);\n    return `0x${hex}`;\n}\nif (typeof window !== 'undefined') {\n    window.keccak256 = keccak256;\n}\nmodule.exports = keccak256;\n"]},"metadata":{},"sourceType":"script"}
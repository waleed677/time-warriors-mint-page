{"ast":null,"code":"//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n// do the universal module definition dance\n(function (root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n})(this, function () {\n  function makePrefix(key, last) {\n    var str = last ? '└' : '├';\n\n    if (key) {\n      str += '─ ';\n    } else {\n      str += '──┐';\n    }\n\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      } // ... and hide any keys mapped to functions if we've been told to\n\n\n      if (hideFunctions && typeof obj[branch] === \"function\") {\n        continue;\n      }\n\n      keys.push(branch);\n    }\n\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '',\n        index = 0,\n        lastKey,\n        circular,\n        lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function (lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '│') + '  ';\n        }\n\n        if (!circular && lastState[0] === root) {\n          circular = true;\n        }\n      }); // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n\n      line += makePrefix(key, last) + key; // append values and the circular reference indicator\n\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n      callback(line);\n    } // can we descend into the next item?\n\n\n    if (!circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function (branch) {\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length; // hold your breath for recursive action\n\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  }\n\n  ; // --------------------\n\n  var Treeify = {}; // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function (obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  }; // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n\n  Treeify.asTree = function (obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function (line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  }; // --------------------\n\n\n  return Treeify;\n});","map":{"version":3,"sources":["/home/waleed/Desktop/MintWebsites/metaverse/node_modules/treeify/treeify.js"],"names":["root","factory","exports","module","define","amd","treeify","makePrefix","key","last","str","filterKeys","obj","hideFunctions","keys","branch","hasOwnProperty","push","growBranch","lastStates","showValues","callback","line","index","lastKey","circular","lastStatesCopy","slice","length","forEach","lastState","idx","Date","Treeify","asLines","lineCallback","hideFunctionsArg","asTree","tree"],"mappings":"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","sourcesContent":["//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '└' : '├');\n    if (key) {\n      str += '─ ';\n    } else {\n      str += '──┐';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '│') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"]},"metadata":{},"sourceType":"script"}
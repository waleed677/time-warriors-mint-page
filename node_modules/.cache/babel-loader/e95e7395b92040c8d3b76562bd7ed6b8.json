{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n} // Crawl up the constructor chain to find a static method\n\nexport function getStatic(ctor, key) {\n  for (let i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const promises = Object.keys(object).map(key => {\n      const value = object[key];\n      return Promise.resolve(value).then(v => ({\n        key: key,\n        value: v\n      }));\n    });\n    const results = yield Promise.all(promises);\n    return results.reduce((accum, result) => {\n      accum[result.key] = result.value;\n      return accum;\n    }, {});\n  });\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n\n  Object.keys(object).forEach(key => {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  const result = {};\n\n  for (const key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\nconst opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\n\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n\n    const keys = Object.keys(object);\n\n    for (let i = 0; i < keys.length; i++) {\n      let value = null;\n\n      try {\n        value = object[keys[i]];\n      } catch (error) {\n        // If accessing a value triggers an error, it is a getter\n        // designed to do so (e.g. Result) and is therefore \"frozen\"\n        continue;\n      }\n\n      if (!_isFrozen(value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n} // Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\n\n\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(item => deepCopy(item)));\n  }\n\n  if (typeof object === \"object\") {\n    const result = {};\n\n    for (const key in object) {\n      const value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      defineReadOnly(result, key, deepCopy(value));\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport class Description {\n  constructor(info) {\n    for (const key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n  }\n\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nexport function defineReadOnly(object, name, value) {\r\n    Object.defineProperty(object, name, {\r\n        enumerable: true,\r\n        value: value,\r\n        writable: false,\r\n    });\r\n}\r\n// Crawl up the constructor chain to find a static method\r\nexport function getStatic(ctor, key) {\r\n    for (let i = 0; i < 32; i++) {\r\n        if (ctor[key]) {\r\n            return ctor[key];\r\n        }\r\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\r\n            break;\r\n        }\r\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\r\n    }\r\n    return null;\r\n}\r\nexport function resolveProperties(object) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const promises = Object.keys(object).map((key) => {\r\n            const value = object[key];\r\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\r\n        });\r\n        const results = yield Promise.all(promises);\r\n        return results.reduce((accum, result) => {\r\n            accum[(result.key)] = result.value;\r\n            return accum;\r\n        }, {});\r\n    });\r\n}\r\nexport function checkProperties(object, properties) {\r\n    if (!object || typeof (object) !== \"object\") {\r\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\r\n    }\r\n    Object.keys(object).forEach((key) => {\r\n        if (!properties[key]) {\r\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\r\n        }\r\n    });\r\n}\r\nexport function shallowCopy(object) {\r\n    const result = {};\r\n    for (const key in object) {\r\n        result[key] = object[key];\r\n    }\r\n    return result;\r\n}\r\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\r\nfunction _isFrozen(object) {\r\n    // Opaque objects are not mutable, so safe to copy by assignment\r\n    if (object === undefined || object === null || opaque[typeof (object)]) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(object) || typeof (object) === \"object\") {\r\n        if (!Object.isFrozen(object)) {\r\n            return false;\r\n        }\r\n        const keys = Object.keys(object);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            let value = null;\r\n            try {\r\n                value = object[keys[i]];\r\n            }\r\n            catch (error) {\r\n                // If accessing a value triggers an error, it is a getter\r\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\r\n                continue;\r\n            }\r\n            if (!_isFrozen(value)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\r\n}\r\n// Returns a new copy of object, such that no properties may be replaced.\r\n// New properties may be added only to objects.\r\nfunction _deepCopy(object) {\r\n    if (_isFrozen(object)) {\r\n        return object;\r\n    }\r\n    // Arrays are mutable, so we need to create a copy\r\n    if (Array.isArray(object)) {\r\n        return Object.freeze(object.map((item) => deepCopy(item)));\r\n    }\r\n    if (typeof (object) === \"object\") {\r\n        const result = {};\r\n        for (const key in object) {\r\n            const value = object[key];\r\n            if (value === undefined) {\r\n                continue;\r\n            }\r\n            defineReadOnly(result, key, deepCopy(value));\r\n        }\r\n        return result;\r\n    }\r\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\r\n}\r\nexport function deepCopy(object) {\r\n    return _deepCopy(object);\r\n}\r\nexport class Description {\r\n    constructor(info) {\r\n        for (const key in info) {\r\n            this[key] = deepCopy(info[key]);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nclass SafeEventEmitter extends events_1.EventEmitter {\n  emit(type, ...args) {\n    let doError = type === 'error';\n    const events = this._events;\n\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    } // If there is no 'error' event listener then throw.\n\n\n    if (doError) {\n      let er;\n\n      if (args.length > 0) {\n        [er] = args;\n      }\n\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      } // At least give some kind of context to the user\n\n\n      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    if (typeof handler === 'function') {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.default = SafeEventEmitter;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAOA,SAAS,SAAT,CAAwC,OAAxC,EAAgF,OAAhF,EAA4F,IAA5F,EAAmG;AACjG,MAAI;AACF,IAAA,OAAO,CAAC,KAAR,CAAc,OAAd,EAAuB,OAAvB,EAAgC,IAAhC;AACD,GAFD,CAEE,OAAO,GAAP,EAAY;AACZ;AACA,IAAA,UAAU,CAAC,MAAK;AACd,YAAM,GAAN;AACD,KAFS,CAAV;AAGD;AACF;;AAED,SAAS,UAAT,CAAwB,GAAxB,EAAgC;AAC9B,QAAM,CAAC,GAAG,GAAG,CAAC,MAAd;AACA,QAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,CAAV,CAAb;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,IAAI,CAA5B,EAA+B;AAC7B,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAG,CAAC,CAAD,CAAb;AACD;;AACD,SAAO,IAAP;AACD;;AAED,MAAqB,gBAArB,SAA8C,QAAA,CAAA,YAA9C,CAA0D;AACxD,EAAA,IAAI,CAAE,IAAF,EAAgB,GAAG,IAAnB,EAA8B;AAChC,QAAI,OAAO,GAAG,IAAI,KAAK,OAAvB;AAEA,UAAM,MAAM,GAAc,KAAa,OAAvC;;AACA,QAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,MAAA,OAAO,GAAG,OAAO,IAAI,MAAM,CAAC,KAAP,KAAiB,SAAtC;AACD,KAFD,MAEO,IAAI,CAAC,OAAL,EAAc;AACnB,aAAO,KAAP;AACD,KAR+B,CAUhC;;;AACA,QAAI,OAAJ,EAAa;AACX,UAAI,EAAJ;;AACA,UAAI,IAAI,CAAC,MAAL,GAAc,CAAlB,EAAqB;AACnB,SAAC,EAAD,IAAO,IAAP;AACD;;AACD,UAAI,EAAE,YAAY,KAAlB,EAAyB;AACvB;AACA;AACA,cAAM,EAAN,CAHuB,CAGb;AACX,OATU,CAUX;;;AACA,YAAM,GAAG,GAAG,IAAI,KAAJ,CAAU,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC,OAAO,GAAlB,GAAwB,EAAE,EAAzD,CAAZ;AACC,MAAA,GAAW,CAAC,OAAZ,GAAsB,EAAtB;AACD,YAAM,GAAN,CAbW,CAaA;AACZ;;AAED,UAAM,OAAO,GAAG,MAAM,CAAC,IAAD,CAAtB;;AAEA,QAAI,OAAO,KAAK,SAAhB,EAA2B;AACzB,aAAO,KAAP;AACD;;AAED,QAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,MAAA,SAAS,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,CAAT;AACD,KAFD,MAEO;AACL,YAAM,GAAG,GAAG,OAAO,CAAC,MAApB;AACA,YAAM,SAAS,GAAG,UAAU,CAAC,OAAD,CAA5B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,IAAI,CAA9B,EAAiC;AAC/B,QAAA,SAAS,CAAC,SAAS,CAAC,CAAD,CAAV,EAAe,IAAf,EAAqB,IAArB,CAAT;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AA7CuD;;AAA1D,OAAA,CAAA,OAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"events\");\r\nfunction safeApply(handler, context, args) {\r\n    try {\r\n        Reflect.apply(handler, context, args);\r\n    }\r\n    catch (err) {\r\n        // Throw error after timeout so as not to interrupt the stack\r\n        setTimeout(() => {\r\n            throw err;\r\n        });\r\n    }\r\n}\r\nfunction arrayClone(arr) {\r\n    const n = arr.length;\r\n    const copy = new Array(n);\r\n    for (let i = 0; i < n; i += 1) {\r\n        copy[i] = arr[i];\r\n    }\r\n    return copy;\r\n}\r\nclass SafeEventEmitter extends events_1.EventEmitter {\r\n    emit(type, ...args) {\r\n        let doError = type === 'error';\r\n        const events = this._events;\r\n        if (events !== undefined) {\r\n            doError = doError && events.error === undefined;\r\n        }\r\n        else if (!doError) {\r\n            return false;\r\n        }\r\n        // If there is no 'error' event listener then throw.\r\n        if (doError) {\r\n            let er;\r\n            if (args.length > 0) {\r\n                [er] = args;\r\n            }\r\n            if (er instanceof Error) {\r\n                // Note: The comments on the `throw` lines are intentional, they show\r\n                // up in Node's output if this results in an unhandled exception.\r\n                throw er; // Unhandled 'error' event\r\n            }\r\n            // At least give some kind of context to the user\r\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\r\n            err.context = er;\r\n            throw err; // Unhandled 'error' event\r\n        }\r\n        const handler = events[type];\r\n        if (handler === undefined) {\r\n            return false;\r\n        }\r\n        if (typeof handler === 'function') {\r\n            safeApply(handler, this, args);\r\n        }\r\n        else {\r\n            const len = handler.length;\r\n            const listeners = arrayClone(handler);\r\n            for (let i = 0; i < len; i += 1) {\r\n                safeApply(listeners[i], this, args);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.default = SafeEventEmitter;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}